\chapter{Введение в программирование на Perl}
\section{Базовый синтаксис языка Perl}
Синтаксис языка Perl близок к синтаксису языка C, а также в нем реализованы идеи и конструкции из shell, awk (популярная утилита для работы с табличными данными), sed и так далее.

\subsection{Простые конструкции в Perl}
Каждая программа на Perl представляет собой последовательность утверждений (statement). Комментарии в языке Perl начинаются с символа \verb|#|.
\begin{minted}{perl}
$a = 42;
say "test";
eval { ... };
do { ... };
my $var;
# Комментарий
\end{minted}
Каждое утверждение возвращает некоторое значение.
\begin{minted}{perl}
# Простые конструкции возвращают значение
$a = 42;        # => 42
say "test";     # => 1
eval { 7 };     # => 7
do { 1; 2; 3 }; # => 3
my $var;        # => undef
\end{minted}
Если утверждение --- это вызов функции, возвращается то значение, которое было возвращено функцией. Если утверждение --- это присвоение переменной некоторого значения, то возвращается значение этой переменной.

\subsection{Инициализация переменных. Режим strict}
Следует отметить, что Perl --- нетипизированный язык, то любой переменной можно присвоить любое значение. Одна и та же переменная в различных участках программы может принимать значения разных типов.

Одна из особенностей Perl заключается в том, что новые переменные инициализируются автоматически в момент использования. Это было очень удобно для создания программ-однострочек, но создавало массу проблем в крупных проектах, когда при опечатке в имени какой-либо переменной Perl просто создавал еще одну переменную, менялась логика работы программы, но эта ошибка оставалась незамеченной.

Поэтому в Perl появилась специальная директива strict, которая включает так называемый строгий режим. В этом режиме все переменные должны быть явно инициализированы до их первого использования. В ином случае работа программы завершается с ошибкой. Инициализация переменной происходит с помощью команды my. Хорошим тоном считается писать все программы (длиной более строчки) в режиме strict.

\subsection{Блоки. Область видимости переменной}
Блоком (scope) называется все, что заключено в фигурные скобки:
\begin{minted}{perl}
{
statement;
statement;
...
}
\end{minted}
Переменные, объявленные внутри такого блока, не видны за его пределами. Это свойство позволяет локализовывать части кода.


\subsection{Управляющие конструкции}
В Perl доступны следующие управляющие конструкции:
\begin{itemize}
  \item \textbf{Условия:} \verb|if|, \verb|unless|, \verb|elsif|, \verb|else|
  \begin{minted}{perl}
    if     ( EXPR ) { ... }
    elsif  ( EXPR ) { ... }
    else            { ... }
  \end{minted}
  С помощью \verb|else| и \verb|elsif| (именно так, а НЕ \verb|elseif| или \verb|else if|) можно указать, что должно быть выполнено, если условие не выполнено. Команда \verb|elsif|, в отличие от \verb|else|, сначала проверяет другое условие. Если условие выполняется, то исполняется код в фигурных скобках, а в ином случае программа переходит к следующему \verb|elsif| или  \verb|else|, если они есть.

  Такой же синтаксис и у команды \verb|unless|:
  \begin{minted}{perl}
      unless ( EXPR ) { ... }
  \end{minted}
  В этом случае код в фигурных скобках выполняется только, если выполнено условие в круглых скобках. При этом плохим тоном считается использование конструкций такого вида:
  \begin{minted}{perl}
      unless ( EXPR ) { ... }
      elsif  ( EXPR ) { ... }
      else            { ... }
  \end{minted}

  \item \textbf{Циклы:} \verb|while|, \verb|until|, \verb|for|, \verb|foreach|
  \begin{minted}{perl}
  while ( EXPR ) { ... }
  \end{minted}
  Оператор \verb|while| исполняет код в теле цикла, пока выполнено некоторое условие. Использование ключевого слова \verb|continue| позволяет указать блок кода, который будет выполнен всегда после каждой итерации. Например, если был совершен преждевременный выход из цикла, блок \verb|continue| все равно будет выполнен. Оператор \verb|until| имеет похожий синтаксис, но выполняет код в теле цикла, пока условие не выполнено:
  \begin{minted}{perl}
  until ( EXPR ) { ... } continue { ... }
  \end{minted}
  Еще два оператора for и foreach являются синонимами в Perl и позволяют итерировать по значениям целочисленной переменной и по элементам списка:
  \begin{minted}{perl}
  for ( EXPR; EXPR; EXPR ) { ... }
  for ( LIST ) { ... }
  for VAR ( LIST ) { ... } # Объявляется переменная, которая будет доступна в обоих scope.
  for VAR ( LIST ) { ... } continue { ... }
  \end{minted}
  \item \textbf{Выбор:} \verb|given|, \verb|when|
  \item \textbf{Безусловный переход:}  \verb|goto|
\end{itemize}

\subsection{Типы данных в Perl}
Основные типы данных в Perl включают в себя:
\begin{itemize}
  \item \textbf{SCALAR}~--- простая переменная, имя всегда начинается с символа \verb|$|, может содержать одно из следующих значений:
  \begin{itemize}
    \item \textbf{Number} (числовое значение): \verb|$s = 1|, \verb|$s = -1e30|.
      Perl работает с числовыми значениями как с числами (то есть быстро) до тех пор, пока не будет к ним обращения как к строке. В последнем случае числовое значение будет преобразовано в строковое.

    \item \textbf{String} (строковое значение): \verb|$s = "str"|. Строка в Perl всегда обрамлена в кавычки.
    \item \textbf{Reference} (ссылка): разыменовывание ссылки \verb|$r| делается в зависимости от того типа данных, который предпологается, что лежит по ссылке:
      \begin{itemize}
        \item \textbf{Scalar} (\verb|$$r|, \verb|${ $r }|)
        \item \textbf{Array} (\verb|@$r|, \verb|@{ $r }|, \verb|$r->[...]|)
        \item \textbf{Hash} (\verb|%$r|, \verb|%{ $r }|, \verb|$r->{...}|)
        \item \textbf{Function} (\verb|&$r|, \verb|&{$r}|, \verb|$r->(...)|)
        \item \textbf{Filehandle} (\verb|*$r|)
        \item \textbf{Lvalue} (\verb|$$r|, \verb|${ $r }|)
        \item \textbf{Reference} (\verb|$$r|, \verb|${ $r }|)
      \end{itemize}
    Нужно иметь в виду, что, если разыменовать ссылку на хэш как массив, получится каша, а именно: получится массив из поочередно ключей и соответствующих значений.
  \end{itemize}
  \item \textbf{ARRAY} (\verb|@a|, \verb|$a[...]|)
  \item \textbf{HASH} (\verb|%h|, \verb|$h{key}|, \verb|$h{...}|)
\end{itemize}


\subsection{Специальные переменные}
В perl существуют специальные глобальные переменные, которые позволяют существенно упростить написание программ:
\begin{itemize}
  \item \verb|$_|, \verb|$ARG| --- аргумент по умолчанию,
  \item \verb|@_|, \verb|@ARG| --- аргументы функции (как массив).
  \item \verb|$a|, \verb|$b| --- переменные, используемые при сортировке:
  \begin{minted}{perl}
  for (sort { $a <=> $b } @ARGV) {
  say "Arg: $_";
  }
  say "Was run by $ENV{USER}";
  \end{minted}
  Поэтому при написании программы категорически не рекомендуется заводить переменные с такими же именами.
  \item \verb|%ENV| --- переменные окружения (как хэш),
  \item \verb|@ARGV| --- аргументы программы (как массив).
\end{itemize}
Также существуют следующие специальные переменные:
\begin{itemize}
  \item \verb|$"|, \verb|$LIST_SEPARATOR| --- разделитель при интерполяции в кавычках.
  \item \verb|$,|, \verb|$OUTPUT_FIELD_SEPARATOR| --- разделитель между элементами списка при выводе (при выводе на экран массива его элементы будут разделены этим символом)
  \item \verb|$/|, \verb|$INPUT_RECORD_SEPARATOR| --- разделитель входного потока для readline
  \item \verb|$\|, \verb|$OUTPUT_RECORD_SEPARATOR| --- разделитель выходного потока для print
  \item \verb|$.|, \verb|$INPUT_LINE_NUMBER|
\end{itemize}
Пример использования:
\begin{minted}{perl}
$" = "."; # $LIST_SEPARATOR
$, = ";"; # $OUTPUT_FIELD_SEPARATOR
$\ = "\n\n"; # $OUTPUT_RECORD_SEPARATOR
while (<>) {
    chomp;
    @a = split /\s+/, $_;
    say "$. @a",@a;
    }
\end{minted}
Есть еще ряд специальных переменных:
\begin{itemize}
  \item \verb|$!|,  \verb|ERRNO|~--- переменная в которую записываются ошибки при открытии файлов.
  \item \verb|$<|,  \verb|UID|~--- ID пользователя, запустившего программу.
  \item \verb|$$|,  \verb|PID|~--- PID процесса
  \item \verb|$0|,  \verb|PROGRAM_NAME|~--- Имя программы
  \item \verb|$^X|,  \verb|EXECUTABLE_NAME|~--- название запущенного бинарного файла
  \item \verb|$^O|,  \verb|OSNAME|~--- имя используемой операционной системы
  \item \verb|$^V|,  \verb|PERL_VERSION|~--- версия perl
\end{itemize}

Например:
\begin{minted}{perl}
say "I'm $^X, $^V, on $^O";
say "Script: $0 (@ARGV);";
say "Pid $$ by uid $<";
open my $f, '<','/etc/shadow'
or die "No shadow: $!\n";
\end{minted}

\begin{minted}{bash}
/usr/bin/perl sample.pl -test
\end{minted}

\begin{verbatim}
# I'm /usr/bin/perl, v5.18.2, on darwin
# Script: sample.pl (-test);
# Pid 70032 by uid 502
# No shadow: No such file or directory
\end{verbatim}

\section{Настройка окружения}
\subsection{Система CPAN}
Perl завоевал к себе доверие, за счет того, что был портирован под всевозможные платформы и системы, а также за счет большой системы CPAN. CPAN --- архив модулей, написанных на языке программирования Perl.
Все версии модулей под все версии perl проходят тестирование (разработчик модуля должен сам должен предоставить тесты) автоматической системой на CPAN. Эта система запускает модуль на каждой версии perl и отмечает результат выполнения тестов в специальной таблице. Часто при крупных обновлениях perl некоторые модули перестают работать, поэтому при выборе модуля для работы эта таблица может оказаться полезной.

%![Right-aligned image](matrixcpantesters.png)
\subsection{Настройка окружения в Mac OS}
Сам perl уже предустановлен (узнать версию можно, если набрать \verb|perl -v| в командной строке), но для сборки сторонних XS-модулей придётся установить xcode, <<Command line tools>>. Также, возможно, придется использовать macports (это perl установленный в отдельную директорию, отличный от системного).

Подробнее про установку можно прочитать в perldoc \perldoc{perlmacosx}.

\subsection{Настройка окружения в Linux}
Как правило перл есть в репозиториях дистрибутива. Команды для установки для некоторых дистрибутивов:
\begin{itemize}
 \item для CentOS: \verb|yum install perl| (Как правило в CentOS версия perl обновляется крайне редко. Поэтому, если необходима более современная версия, ее придется собирать самостоятельно.)
 \item для Debian: \verb|apt-get install perl|
 \item для GenToo: \verb|emerge dev-lang/perl|
 \item для FreeBSD: \verb|pkg add perl|
\end{itemize}
Сборки Perl есть почти под все операционные системы, даже под некоторые микроконтроллеры. Чтобы самостоятельно собрать perl, нужно скачать исходный код и выполнить:
\begin{minted}{bash}
make perl ./Configure -des; make test instal
\end{minted}
Если нужно установить его в другую директорию, нужно указать это с помощью ключей для make.

\subsection{Настройка окружения в Windows}
Для Windows существует несколько дистрибутивов Perl:
\begin{itemize}
  \item \textbf{ActivePerl от ActiveState}. Фирма ActiveState знаменита тем, что сделала Perl продакшн-системой, модули для которой они продавали.
  \item \textbf{StrawberryPerl} (рекомендуется использовать). В отличие от ActivePerl, StrawberryPerl идёт сразу с компилятором mingw, а также существенно удобнее и проще установка модулей.
  \item \textbf{cygwin}
\end{itemize}
С ActivePerl надо позаботится о наличие nmake + win32GnuUtils иначе сборка модулей будет мучительной и утомляющей.


\subsection{Проверка доступности интепретатора}
Чтобы проверить доступность интерпретатора, необходимо набрать в терминале:
\begin{minted}{bash}
  perl -v
\end{minted}
Выдача будет примерно такой:
\begin{minted}{bash}
This is perl 5, version 18, subversion 2 (v5.18.2) built for
x86_64-linux-gnu-thread-multi
(with 40 registered patches, see perl -V for more detail)

Copyright 1987-2013, Larry Wall

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using "man perl" or "perldoc perl".  If you have access to the
Internet, point your browser at http://www.perl.org/, the Perl Home Page.
\end{minted}

Если вместо этого выводится ошибка <<Command not found>> или какая-то другая, то с установкой, что то пошло не так. Возможно, интерпретатор находится за пределами возможных путей из переменной окружения среды PATH.

\section{Запуск однострочных скриптов}
Perl в начале своего развития использовался для запуска и исполнения простейших однострочных скриптов. Также, за исключением небольшого числа системнозависимых библиотек, Perl на всех операционных системах работает одинаково. Именно поэтому Perl был так популярен среди системных администраторов.

При написании однострочников \verb|use strict;| писать необязательно. Но если вдруг скрипт начал выполнять не то, что задумано, лучше добавить \verb|use strict;|, что упростит отладку.

Запустить однострочник можно с помощью ключа \verb|-e|, после которого идет код однострочника в кавычках:
\begin{minted}{bash}
perl -e 'print "Hello world\n"'
\end{minted}
Использовать всегда следует одинарные кавычки, так как разные шеллы по-разному работают с двойными кавычками, и существует соглашение, что одинарные кавычки --- неинтерполируемые (то есть в них не будут подставляться переменные среды). Обычно однострочная программа, обрабатывает данные приходящие ей в стандартном вводе. Вот простейшая программа которая читает стандартный ввод и распечатывает строки добавляя в начало каждой из них дефис
\begin{minted}{bash}
perl -e 'while(<>){print "- ".$_}'
\end{minted}
Чтобы постоянно не использовать конструкцию \verb|while(<>){}| при выполнении действия над каждой строчкой в файле, существует ключ \verb|-n|. Идентичная запись той же программы:
\begin{minted}{bash}
perl -ne 'print "- ".$_'
\end{minted}
Внутри цикла \verb|while(<>){}| переменная \verb|$_| будет содержать цельную строку вместе с символом \verb|\n|. Что бы не использовать команду chomp (отрезающую в конце перенос строки) можно использовать флаг \verb|-l|, который:
\begin{itemize}
  \item устанавливает переменную \verb|$\| (разделитель, который выведен после каждого выполнения команды print)
  \item устанавливает переменную \verb|$/| (разделитель по которому будет делится входящий поток, отдельно его можно выставить с помощью флага \verb|-0|)
  \item удаляет из строки \verb|$_| последний перенос строки (при совместном использовании с флагом \verb|-n|)
\end{itemize}
Например, прочитать файл в котором записи разделены через \verb|";"| и вывести каждую запись на новой строке можно так:
\begin{minted}{bash}
perl -nl00120073 -e 'print $_'
\end{minted}
Все строки из файла записать через \verb|";"| можно так:
\begin{minted}{bash}
perl -nl00730012 -e 'print $_'
\end{minted}
Флаг \verb|-p| делает тоже самое, что и флаг \verb|-n|, только в каждую итерацию цикла добавит еще вывод переменной \verb|$_|:
\begin{minted}{bash}
perl -nl00120073 -e ''
\end{minted}
\begin{minted}{bash}
perl -pl00730012 -e ''
\end{minted}
Детальнее можно посмотреть тут: perldoc \perldoc{perlvar}.

Для парсинга более сложных структур файлов (например, когда в каждой строке есть записи разделенные определённым разделителем), можно использовать флаг  \verb|-a| совместно с \verb|-F|:
\begin{itemize}
  \item Флаг \verb|-a| добавляет функцию разделяющую входную строку на части и складывает в спецмассив \verb|@F|
  \item \verb|-F| устанавливает разделитель (по умолчанию это пробел)
\end{itemize}
Например, с помощью следующего кода можно прочитать файл-таблицу, в которой каждая строка представляет собой набор полей разделенных \verb|";"|, проверить третью колонку на наличие там 1 и при выполнении условия вывести значение из 2 колонки:
\begin{minted}{perl}
perl -lnaF';' -e 'if( $F[2] == 1 ){ print $F[1] };'
\end{minted}
В этом примере флаг \verb|-l| необходим, чтобы выполнять скрипт для каждой строки файла.

Подключить модули (чтобы иметь возможность пользоваться функциями этого модуля) можно опцией \verb|-M|, например:
\begin{minted}{perl}
perl -MJSON::XS -e 'print JSON::XS::encode_json({var1 => 1, var2 => 2})'
\end{minted}
Perl поддерживает еще много других ключей, но представленных должно быть достаточно для начала изучения языка.

\section{Средства отладки в Perl}
\subsection{Доступ к кодам операции}
В perl 5 (начиная с версии 5.005) был обеспечен доступ к компилятору. По умолчанию Perl переводит исходный код в коды операции и исполняет их. Если коды операции нужно не исполнить, а передавать в какой-то модуль (для таких модулей было выделено пространство имен \verb|B::|), который сам будет решать, что с ними нужно делать, следует использовать флаг \verb|-MO|:
\begin{minted}{perl}
perl -MO=Backend
\end{minted}
Указанный модуль может вывести коды операций на экран, проанализировать быстродействие и так далее. Эта функция будет особенно полезна при отладке. Например, \verb|B::Concise| --- модуль, позволяющий вывести коды операции как есть.

\subsection{Модуль Deparse}
\verb|B::Deparse| --- модуль, который превращает коды операции после компилятора обратно в код на perl, то есть декомпилирует байткод. У этого модуля есть множество опций, позволяющих менять его поведение.

Работу модуля можно продемонстрировать на программе
\begin{minted}{perl}
perl -pl00730012 -e ''
\end{minted}
запуская perl с подключенным модулем B::Deparse:
\begin{minted}{perl}
perl -MO=Deparse -pl00730012 -e ''
\end{minted}
На выходе получается:
\begin{minted}{perl}
BEGIN { $/ = "\n"; $\ = ";"; }
LINE: while (defined($_ = <argv>) ){
    chomp $_;
}
continue {
    die "-p destination: $!\n" unless print $_;
}
-e syntax OK
\end{minted}
У модуля B::Deparse есть свои удобные ключи:
\begin{itemize}
  \item \verb|-l| добавит комментарии с ссылками на строки исходного файла
  \item \verb|-p| расставит скобки и тем самым покажет приоритетность выполнения команд
  \item \verb|-q| развернёт интерполируемые строки, то есть представит их как конкатенацию неинтерполируемых строк и переменных. Интерполирование строк --- это поиск внутри строчек, которые обрамлены в двойные кавычки, имен переменных и замена их на соответствующие им значения:
  \begin{minted}{perl}
  "Hello $name" = 'Hello ' . $name != 'Hello $name'
  \end{minted}
  Строки в одинарных кавычках не интерполируются.
  \item Ключ \verb|-sС| определяет стиль вывода кода.
  \item Ключ \verb|-siNUMBER| определяет количество пробелов в отступе
  \item Ключ \verb|-siT| позволяет использовать символ табуляции
  \item Ключ \verb|-xNUMBER| определяет уровень развертывания кода
\end{itemize}
\verb|B::Deparse| можно использовать, как обычный модуль, передавая ему ссылку на функцию, код которой хочется посмотреть (в том числе, если доступна только ссылка на функцию):
\begin{minted}{perl}
use B::Deparse;
sub func {
    print 'Hello world!!!'
};

my $deparse = B::Deparse->new("-p", "-sC");
$body = $deparse->coderef2text(\&func);

print $body;
\end{minted}
После выполнения такой программы:
\begin{minted}{perl}
{
print('Hello world!!!');
}
\end{minted}

При уровне отладки большем чем 3 все циклы for будут развёрнуты в while. Код:
\begin{minted}{bash}
perl -MO=Deparse,x3 -e 'for ($i = 0; $i < 10; ++$i) {print $i;}'
\end{minted}
Превратится в
\begin{minted}{perl}
$i = 0;
while ($i < 10) {
    print $i;
} continue {
    ++$i
}
\end{minted}
\subsection{Data::Dumper}
\verb|Data::Dumper| - модуль, который поможет выводить на экран в развернутом виде сложные структуры данных. Например:
\begin{minted}{perl}
use Data::Dumper;
my $foo = [{a => 1, b => 2},{c => 3, d => 4}];
print Dumper($foo);
\end{minted}
Вот так красиво демонстрирует эту переменную \verb|Data::Dumper|:
\begin{minted}{perl}
$VAR1 = [
    {
      'b' => 2,
      'a' => 1
    },
    {
      'c' => 3,
      'd' => 4
    }
];
\end{minted}
У \verb|Data::Dumper| есть множество опций, которые позволяют управлять стилем вывода: табуляцией, переносом строк и так далее.

\subsection{Модуль DDP (Data::Printer)}
Есть альтернативный модуль для просмотра структур и объектов. Его обычно используют для отладки приложений. У этого модуля не меньше настроек, чем у Data::Dumper, но его проще использовать, например:
\begin{minted}{perl}
use DDP;
my $foo = {a=>1, b=> 2, c=> [1,2,3]};
p $foo;
\end{minted}
Вывод следующий:
\begin{minted}{perl}
\ {
    a   1,
    b   2,
    c   [
        [0] 1,
        [1] 2,
        [2] 3
    ]
}
\end{minted}
Модуль DDP в основном отличается от Data::Dumper следующим:
\begin{itemize}
  \item Автор этого модуля позаботился о цветовой разметке выводимых данных, для удобства чтения.
  \item Так же у этого модуля более расширенный дамп объектов:
  \begin{minted}{perl}
  \ SomeClass  {
    Parents       Moose::Object
    Linear @ISA   SomeClass, Moose::Object
    public methods (3) : bar, foo, meta
    private methods (0)
    internals: {
      _something => 42,
    }
  }
  \end{minted}
  \item Отсутствует сериализация.
\end{itemize}

\subsection{Использование отладчика}
Для начала работы с дебагером рекомендуется прочитать документацию \perldoc{perldebtut}. Отладка программ подразумевает построчное их выполнение с возможностью просмотра состояния переменных между ними.

Запуск отладчика выполняется добавлением ключа \verb|-d| при запуске интерпретатора:
\begin{minted}{perl}
perl -d myscript.pl
\end{minted}
Для того, что бы отладчик запустился скрипт не должен содержать синтаксических ошибок и должен нормально компилироваться через \verb|perl -c|. После запуска отладчика на экране появится:
\begin{minted}{bash}
Loading DB routines from perl5db.pl version 1.44
Editor support available.

Enter h or 'h h' for help, or 'perldoc perldebug' for more help.

DB<1>
\end{minted}
Далее отладчик ждёт команд. Некоторые команды отладчика для просмотра кода и значения переменных:
\begin{verbatim}
- l посмотреть код. Параметра можно указать номер строки, номер строки + интервал, диапазон строк, название функции. На выход вы получаете запрошенный код
- - посмотреть предыдущий код относительно текущей строки
- v посмотреть код вокруг указанной строки
- / поиск по коду в прямом направлении на вход эта команда принимает регулярное выражение, если ничего не передавать то отладчик продолжит поиск по предыдущему запросу
- ? поиск по коду в обратном направлении
- f загрузка файла для просмотра, на вход принимает имя файла
- . вернуть указатель на текущую позицию выполнения кода
- m $obj показать все методы объекта
- M показать список всех загруженных модулей
- S список всех доступных функций в данной точке
- [X|V] [Package] [str|~re] список переменных. Можно передать имя пакета внутри которого интересуют переменные, название переменно или регулярное выражение для названия переменной
\end{verbatim}
Команды отладчика для выполнения кода:
\begin{verbatim}
- p выполнить перл выражение и показать результат
- n шаг вперёд без захода в процедуру
- s шаг вперёд с заходом в процедуру
- T стек вызовов в данной точке
- ! повторить предыдущую команду. На вход можно передать номер команды в истории которую надо повторить
- source file - выполнить команды из файла
- с продолжить выполнение программы. Если параметром указать номер строки или имя функции, то отладчик продолжит выполнение до указанного места
- r продолжить выполнение скрипта до выхода из подпрограммы
- q выход из отладчика
\end{verbatim}
Точки останова, действия, точки наблюдения
\begin{verbatim}
- b < line|sub > [условие] - установить точку останова на указанную строку или функцию при выполнении условия
- B < ln|* > - снять точку останова
- a строка действие [условие] - установить действие которое сработает достигнув определённой строки
- A < line|* > - удалить действие
- w $var - установить наблюдение за переменной
- W $var|* - снять наблюдение за переменной
- L [a|b|w] - вывести список точек останова, действий, наблюдений за переменными
- R - начать скрипт заново оставив все точки останова, действия, наблюдения
\end{verbatim}

\subsection{Использование отладчика: пример}
В качестве примера будет показана отладка следующего скрипта:
\begin{minted}{perl}
use strict;

my $ret = 0;

foreach ( my $i = 0 ; $i < 50 ; $i++ ) {
    if ( $ret > $i ) {
        $ret -= $i;
    }
    else {
        $ret += $i;
    }
}
print $ret;
\end{minted}
Запуск отладки:
\begin{minted}{bash}
perl -d mydebug.pl
\end{minted}
Отладчик запустился и выдал приглашение:
\begin{minted}{bash}
Loading DB routines from perl5db.pl version 1.44
Editor support available.

Enter h or 'h h' for help, or 'perldoc perldebug' for more help.

main::(mydebug.pl:3):   my $ret = 0;

DB< 1 >
\end{minted}
Команда \verb|l| позволяет просмотреть код с указанием текущей позиции:
\begin{minted}{perl}
3==>    my $ret = 0;
4:      my $cnt_add = 0;
5:      my $cnt_sub = 0;
6
7:      foreach(my $i = 0; $i < 50; $i++){
8:              if($ret>$i){
9:                      $ret -= $i;
10              }
11              else {
12:                     $ret += $i;
\end{minted}
Установка точки останова (команда \verb|b|) на 8ой строчке при достижении 10 итерации цикла:
\begin{minted}{bash}
b 8 $i == 9
\end{minted}
Запуск программы (команда \verb|c|)
\begin{minted}{bash}
c
\end{minted}
Когда выполнится условие \verb|$i == 9|, сработает точка останова и на экране появится сообщение:
\begin{minted}{bash}
DB< 7 >
c
main::(mydebug.pl:8):           if($ret > $i){
\end{minted}
Вывод значения переменной \verb|$i|:
\begin{minted}{bash}
DB< 7 > print $i
9
\end{minted}
Отслеживать переменные можно командой \verb|$w|:
\begin{minted}{bash}
w $ret
\end{minted}
После этого выполнив 1 строчку (команда \verb|n|):
\begin{minted}{bash}
DB< 9 >
n
Watchpoint 0:   $ret changed:
old value:  ''
new value:  '16'
main::(mydebug.pl:9):                   $ret -= $i;

DB< 9 >
\end{minted}
Дальнейшая отладка происходит по тем же принципам.
